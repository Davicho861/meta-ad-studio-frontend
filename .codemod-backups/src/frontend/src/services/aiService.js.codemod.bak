// AI service using Replicate to generate images via Stable Diffusion XL (SDXL).
// The Replicate API token must be available in `process.env.REPLICATE_API_TOKEN`.

import Replicate from 'replicate'
import { parsePrompt } from '../utils/promptParser'
import { addGeneration } from './dbService'
import useAdStore from '../store/adStore'

const MODEL = 'stability-ai/sdxl:39ed52f2a78e934b3ba6e2a89f5b1c712de7dfea535523a55ff1e3b32d86de8a'

/**
 * Generate ad creatives by calling Replicate's SDXL model.
 * Returns an array of objects compatible with the front-end: { id, title, description, imageUrl, metrics }
 * If the API call fails, an empty array is returned and the error is logged.
 *
 * Note: Ensure `REPLICATE_API_TOKEN` is set in the environment (or bundled into Electron runtime) before calling.
 */
export async function generateAdCreatives(rawPrompt) {
  if (!rawPrompt || !rawPrompt.trim()) return []

  const token = process.env.REPLICATE_API_TOKEN
  if (!token) {
    console.error('REPLICATE_API_TOKEN is not set. Returning empty results.')
    return []
  }

  const replicate = new Replicate({ auth: token })

  // Parse advanced params from prompt
  const { prompt, params } = parsePrompt(rawPrompt)

  // Prepare inputs for the model; merge prompt + known params
  const input = Object.assign({ prompt }, params)

  // Update store to running
  const setGenerationProgress = useAdStore.getState().setGenerationProgress
  if (setGenerationProgress) {
    setGenerationProgress({ status: 'running', logs: ['Starting prediction...'] })
  }

  try {
    const images = []

    // Use replicate.stream if available to receive progress logs
    // The stream callback provides lines; push them to store logs
    await replicate.stream(MODEL, {
      input,
      onMessage: async (message) => {
        try {
          const setGen = useAdStore.getState().setGenerationProgress
          // message may contain event types; we append text
          if (setGen) {
            setGen((prev) => ({ status: 'running', logs: [...(prev?.logs || []), String(message)] }))
          }

          // Some stream messages include output URLs; if message.output present, collect
          if (message?.output) {
            if (Array.isArray(message.output)) images.push(...message.output)
            else images.push(message.output)
          }
        } catch (e) {
          console.debug('stream onMessage handler error', e)
        }
      },
    })

    // If no images were collected during stream, try a fallback run
    if (images.length === 0) {
      const res = await replicate.run(MODEL, { input })
      if (Array.isArray(res)) images.push(...res)
      else images.push(res)
    }

    const now = Date.now()
    const results = images.map((url, idx) => ({
      id: `${now}-${idx}`,
      title: `Ad for: ${prompt} (${idx + 1})`,
      description: `Generated by SDXL via Replicate for prompt: "${prompt}"`,
      imageUrl: url,
      metrics: { ctr: '0.00', cpc: '0.00' },
    }))

    // Persist the generation record (non-blocking)
    try {
      await addGeneration({ prompt: rawPrompt, parsed: { prompt, params }, results })
    } catch (e) {
      console.warn('Failed to persist generation to local DB', e)
    }

    // Update store to succeeded
    if (setGenerationProgress) setGenerationProgress({ status: 'succeeded', logs: ['Finished'] })

    return results
  } catch (err) {
    console.error('Error generating images from Replicate:', err)
    if (setGenerationProgress) setGenerationProgress({ status: 'failed', logs: [String(err)] })
    return []
  }
}

export default { generateAdCreatives }
