# Backlog Priorizado de Implementación Técnica

Este documento desglosa las "Acciones Clave" identificadas en el informe de diagnóstico en un backlog de tareas técnicas accionables, priorizadas para llevar la "Meta Studio Ad Studio App SPA" a un estado de "production-ready".

| Épica | User Story / Tarea Técnica | Criterios de Aceptación | Prioridad |
| :--- | :--- | :--- | :--- |
| **Accesibilidad** | Como usuario con discapacidad motriz, quiero poder navegar por toda la aplicación, incluida la galería de multiversos, usando únicamente mi teclado. | 1. Todos los elementos interactivos (botones, enlaces, inputs) son enfocables y accionables mediante `Tab` y `Enter`/`Espacio`.<br>2. El elemento con foco tiene un indicador visual claro y perceptible (outline).<br>3. La navegación sigue un orden lógico y predecible. | **P0** |
| **Accesibilidad** | Como usuario con discapacidad visual, quiero que todas las imágenes tengan descripciones alternativas (`alt text`) para entender su contenido a través de un lector de pantalla. | 1. Todas las etiquetas `<img>` y componentes de imagen tienen un atributo `alt` descriptivo y conciso.<br>2. Las imágenes puramente decorativas tienen un `alt=""` vacío.<br>3. La auditoría con herramientas como Lighthouse o Axe no reporta imágenes sin texto alternativo. | **P0** |
| **Performance** | Implementar "lazy loading" para las imágenes y componentes pesados en la galería principal para acelerar el tiempo de carga inicial (LCP y FCP). | 1. Las imágenes y componentes que están fuera del viewport inicial no se cargan al cargar la página.<br>2. La puntuación de "Performance" en una auditoría de Lighthouse mejora en al menos 15 puntos.<br>3. Se muestra un placeholder (skeleton o blur) mientras los recursos cargan. | **P0** |
| **Performance** | Implementar "code splitting" a nivel de ruta para que los usuarios solo descarguen el código JavaScript necesario para la vista que están visitando. | 1. El bundle de JavaScript principal (`main.js` o `index.js`) reduce su tamaño significativamente.<br>2. Al navegar a una nueva ruta (ej. `/multiverse/:id`), se carga un nuevo "chunk" de JS visible en la pestaña Network.<br>3. Se utiliza `React.lazy` y `Suspense` para gestionar la carga asíncrona de las rutas. | **P1** |
| **Testing** | Aumentar la cobertura de pruebas unitarias y de integración para los componentes críticos (ej. `MultiverseGallery`, lógica de estado) a un mínimo de 80%. | 1. El comando `npm test -- --coverage` reporta una cobertura global superior al 80%.<br>2. Se han creado pruebas específicas para la lógica de renderizado condicional, interacciones del usuario y manejo de errores.<br>3. Las pruebas se ejecutan correctamente en el pipeline de CI. | **P1** |
| **Testing** | Crear un conjunto de pruebas End-to-End (E2E) con Cypress que cubra el flujo de usuario principal: visualizar la galería, seleccionar un multiverso y ver sus detalles. | 1. Existe un archivo de prueba en `tests/cypress/e2e/` que simula el flujo completo.<br>2. La prueba verifica que los datos se cargan y se muestran correctamente en cada paso.<br>3. El comando `npm run cy:run` se ejecuta sin errores en el pipeline de CI. | **P1** |
| **Gestión de Estado** | Centralizar el estado global de la aplicación, especialmente el fetching de datos, utilizando una librería como React Query o Zustand para evitar "prop drilling" y manejar el cacheo. | 1. Se elimina el paso manual de props a través de múltiples niveles de componentes.<br>2. El estado de carga (loading) y error de las peticiones API se gestiona de forma centralizada.<br>3. Las peticiones a la API se cachean para mejorar la performance en navegaciones repetidas. | **P2** |
| **Diseño UI** | Implementar un modo oscuro (dark mode) completamente funcional y consistente en toda la aplicación. | 1. Existe un interruptor (toggle) que permite al usuario cambiar entre modo claro y oscuro.<br>2. La preferencia del usuario se guarda en `localStorage` y se respeta en visitas futuras.<br>3. Todos los componentes de la UI tienen estilos definidos para ambos modos, sin problemas de legibilidad o contraste. | **P2** |
| **Integración con API** | Implementar un manejo de errores robusto y centralizado para todas las llamadas a la API, mostrando notificaciones (toasts) informativas al usuario. | 1. Los errores de red (ej. 404, 500) son capturados y no rompen la aplicación.<br>2. Se muestra un mensaje claro al usuario indicando que algo salió mal.<br>3. Se utiliza un interceptor (en `axios` o `fetch`) para manejar los errores de forma global. | **P2** |
| **Calidad de Código** | Refactorizar componentes que superen las 200 líneas de código o tengan una complejidad ciclomática alta, dividiéndolos en componentes más pequeños y reutilizables. | 1. Ningún componente excede el umbral de complejidad definido.<br>2. Se identifican y extraen hooks personalizados (`use...`) para la lógica reutilizable.<br>3. El código resultante es más legible, mantenible y fácil de testear. | **P3** |
